import org.gradle.api.tasks.testing.logging.TestExceptionFormat

/*
 * This file was generated by the Gradle 'init' task.
 */

val codeCoverageToolVersion = "0.8.11"
val codeCoverageReports = "reports/codeCoverage"
val codeCoverageThreshold = "0.95".toBigDecimal()

plugins {
    // Apply the java Plugin to add support for Java.
    java

    // Code coverage
    jacoco

    // Formatting
    id("com.diffplug.spotless")
    checkstyle
}

jacoco {
    toolVersion = codeCoverageToolVersion
    reportsDirectory = layout.buildDirectory.dir(codeCoverageReports)
}

spotless {
    java {
        importOrder()
        removeUnusedImports()
        googleJavaFormat()
        formatAnnotations()
    }
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(8)
    }
}



tasks.named<Test>("test") {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform()
    testLogging {
        showExceptions = true
        showStackTraces = true
        exceptionFormat = TestExceptionFormat.FULL
        showCauses = true
        events("skipped", "failed")
    }
}

tasks.test {
    // Report is generated and verification is run after tests
    finalizedBy(tasks.jacocoTestReport, tasks.jacocoTestCoverageVerification)
}

tasks.jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = codeCoverageThreshold
            }
        }
    }
}

tasks.jacocoTestReport {
    reports {
        xml.required = true
        csv.required = false
    }

    dependsOn(tasks.test) // tests are required to run before generating the report
}

// NOTE: This is temporary change to allow us to build uber jars that can be used to integrate
// upstream. Ultimately more thinking around packaging and distribution will be required. 
tasks.register<Jar>("uberJar") {
    archiveClassifier = "uber"

    from(sourceSets.main.get().output)

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    dependsOn(configurations.runtimeClasspath)
    from({
        configurations.runtimeClasspath.get().filter { it.name.endsWith("jar") }.map { zipTree(it) }
    })
}
